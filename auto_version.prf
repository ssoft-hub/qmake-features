!load( message_logging ) : error( Can not find feature \"message_logging\" )
!load( file_system ) : error( Can not find feature \"file_system\" )

!contains( TEMPLATE, .*subdirs ) {

CONFIG( static ) : \
    AUTO_VERSION.variant = header_only

contains( TEMPLATE, .*app ) : \
    AUTO_VERSION.variant = app

isEmpty( AUTO_VERSION.dest_dir ) {
    !load( complex_paths ) : errorLogging( "Can not find feature \"complex_paths\"" )
    AUTO_VERSION.dest_dir = "$${COMPLEX.gen_dir}/AutoVersion"
}

!load( module_depends ) : errorLogging( "Can not find feature \"module_depends\"" )
!load( build_moment ) : errorLogging( "Can not find feature \"build_moment\"" )

isEmpty( AUTO_VERSION.revision ) {
    !load( git_version ) : errorLogging( "Can not find feature \"git_version\"" )
    AUTO_VERSION.version = $${GIT.version}
    AUTO_VERSION.revision = $${GIT.revision}
    AUTO_VERSION.branch = $${GIT.branch}
}

isEmpty( AUTO_VERSION.revision ) {
    !load( svn_version ) : errorLogging( "Can not find feature \"svn_version\"" )
    AUTO_VERSION.version = $${SVN.version}
    AUTO_VERSION.revision = $${SVN.revision}
    AUTO_VERSION.branch = $${SVN.branch}
}

AUTO_VERSION.date = "$$currentDate()"
AUTO_VERSION.time = "$$currentTime()"

isEmpty( AUTO_VERSION.product ) : \
    AUTO_VERSION.product = "$${QMAKE_TARGET_PRODUCT}"

isEmpty( AUTO_VERSION.product ) : \
    AUTO_VERSION.product = "$${TARGET}"

isEmpty( AUTO_VERSION.vendor ) : \
    AUTO_VERSION.vendor = "$${QMAKE_TARGET_COMPANY}"

isEmpty( AUTO_VERSION.copyright ) : \
    AUTO_VERSION.copyright = "$${QMAKE_TARGET_COPYRIGHT}"

isEmpty( AUTO_VERSION.license ) : \
    AUTO_VERSION.license = "$${QMAKE_TARGET_LICENSE}"

isEmpty( AUTO_VERSION.description ) : \
    AUTO_VERSION.description = "$${QMAKE_TARGET_DESCRIPTION}"

TEMP_LIST = $$split( AUTO_VERSION.version, '.' )

TEMP.major = $$member(TEMP_LIST, 0)
TEMP.minor = $$member(TEMP_LIST, 1)
TEMP.patch = $$member(TEMP_LIST, 2)

CHECK.major = $$replace( TEMP.major, [$$escape_expand(\\D)], 0 )
CHECK.minor = $$replace( TEMP.minor, [$$escape_expand(\\D)], 0 )
CHECK.patch = $$replace( TEMP.patch, [$$escape_expand(\\D)], 0 )

isEqual( TEMP.major, $${CHECK.major} ) : isEqual( TEMP.minor, $${CHECK.minor} ) : isEqual( TEMP.patch, $${CHECK.patch} ) {
    AUTO_VERSION.major = $${TEMP.major}
    AUTO_VERSION.minor = $${TEMP.minor}
    AUTO_VERSION.patch = $${TEMP.patch}
}

unset( TEMP )
unset( CHECK )

isEmpty( AUTO_VERSION.major ) : AUTO_VERSION.major = "1"
isEmpty( AUTO_VERSION.minor ) : AUTO_VERSION.minor = "0"
isEmpty( AUTO_VERSION.patch ) : AUTO_VERSION.patch = "0"

greaterThan( QT_MAJOR_VERSION, 4 ) : isEmpty( VERSION ) {
    CONFIG *= skip_target_version_ext
    VERSION = $${AUTO_VERSION.major}.$${AUTO_VERSION.minor}.$${AUTO_VERSION.patch}
}

AUTO_VERSION.namespace = $${TARGET}_AutoVersion
AUTO_VERSION.namespace = $$replace( AUTO_VERSION.namespace, [$$escape_expand(\\W)], _ )

isEqual( AUTO_VERSION.variant, app ) {
    # Too large windows paths error
    win32* | win64* {
        CONFIG -= \
            object_parallel_to_source \
            object_with_source \

        AUTO_VERSION.pwd = "$${AUTO_VERSION.dest_dir}/$${TARGET}"
    } else {
        AUTO_VERSION.pwd = "$${AUTO_VERSION.dest_dir}/$${MODULE.base_dir}"
    }
} else {
    AUTO_VERSION.pwd = "$${AUTO_VERSION.dest_dir}/$${TARGET}"
}

win32* | win64* {
    AUTO_VERSION_EXPORT_DECLARE = "__declspec(dllexport)"
    AUTO_VERSION_IMPORT_DECLARE = "__declspec(dllimport)"
}

AUTO_VERSION.header_file = "$${AUTO_VERSION.pwd}/AutoVersion_p.h"
HEADERS *= "$${AUTO_VERSION.header_file}"

isEqual( AUTO_VERSION.variant, header_only ) {
    AUTO_VERSION.source_file = "$${AUTO_VERSION.header_file}"
    AUTO_VERSION_EXPORT_INLINE = "inline"
} else {
    AUTO_VERSION_EXPORT_VALUE = "AUTO_VERSION_EXPORT"
    AUTO_VERSION.source_file = "$${AUTO_VERSION.pwd}/AutoVersion_p.cpp"
    SOURCES *= "$${AUTO_VERSION.source_file}"
}

tab = $$escape_expand(\\t)

# HEADER FILE
AUTO_VERSION_H_CONTENTS += \
    "$${LITERAL_HASH}pragma once" \
    "$${LITERAL_HASH}ifndef $${AUTO_VERSION.namespace}_H" \
    "$${LITERAL_HASH}define $${AUTO_VERSION.namespace}_H" \
    "//" \
    "$${LITERAL_HASH}include <AutoVersion.h>" \
    "//" \
    "$${LITERAL_HASH}ifdef AUTO_VERSION_EXPORT" \
    "$${LITERAL_HASH}undef AUTO_VERSION_EXPORT" \
    "$${LITERAL_HASH}endif // AUTO_VERSION_EXPORT" \
    "//" \
    "$${LITERAL_HASH}ifdef EXPORT_$${AUTO_VERSION.namespace}" \
    "$${LITERAL_HASH}define AUTO_VERSION_EXPORT $${AUTO_VERSION_EXPORT_DECLARE}" \
    "$${LITERAL_HASH}else" \
    "$${LITERAL_HASH}define AUTO_VERSION_EXPORT $${AUTO_VERSION_IMPORT_DECLARE}" \
    "$${LITERAL_HASH}endif // $${AUTO_VERSION.namespace}_EXPORT" \
    "//" \
    "namespace $${AUTO_VERSION.namespace}" \
    "{" \
    "$${tab}inline ::AutoVersion::Info info ()" \
    "$${tab}{" \
    "$${tab}$${tab}::AutoVersion::Info result;" \
    "$${tab}$${tab}result.product = \"$${AUTO_VERSION.product}\";" \
    "$${tab}$${tab}result.version = \"$${AUTO_VERSION.version}\";" \
    "$${tab}$${tab}result.revision = \"$${AUTO_VERSION.revision}\";" \
    "$${tab}$${tab}result.date = \"$${AUTO_VERSION.date}\";" \
    "$${tab}$${tab}result.time = \"$${AUTO_VERSION.time}\";" \
    "$${tab}$${tab}result.vendor = \"$${AUTO_VERSION.vendor}\";" \
    "$${tab}$${tab}result.copyright = \"$${AUTO_VERSION.copyright}\";" \
    "$${tab}$${tab}result.license = \"$${AUTO_VERSION.license}\";" \
    "$${tab}$${tab}result.description = \"$${AUTO_VERSION.description}\";" \
    "$${tab}$${tab}return result;" \
    "$${tab}}" \
    "}" \
    "//" \
    "namespace $${AUTO_VERSION.namespace}" \
    "{" \
    "$${tab}$${AUTO_VERSION_EXPORT_VALUE} ::AutoVersion::Version version ();" \
    "}" \
    "//" \

AUTO_VERSION_H_CONTENTS_END = "$${LITERAL_HASH}endif // $${AUTO_VERSION.namespace}_H"

# SOURCE FILE
# Generation includes of dependencies
for( depend, LOADED_DEPENDS ) {
    AUTO_VERSION_H_TEMP_FILE = "$${AUTO_VERSION.dest_dir}/$${depend}/AutoVersion_p.h"
    !isEqual( AUTO_VERSION.header_file, $${AUTO_VERSION_H_TEMP_FILE} ) : \
        exists( $${AUTO_VERSION_H_TEMP_FILE} ) : \
            AUTO_VERSION_CPP_CONTENTS += \
                "$${LITERAL_HASH}include \"$${AUTO_VERSION_H_TEMP_FILE}\""
}

AUTO_VERSION_CPP_CONTENTS += \
    "//" \
    "$${LITERAL_HASH}define EXPORT_$${AUTO_VERSION.namespace}" \
    "$${LITERAL_HASH}include \"AutoVersion_p.h\"" \
    "//" \

AUTO_VERSION_CPP_CONTENTS += \
    "//" \
    "namespace $${AUTO_VERSION.namespace}" \
    "{" \
    "$${tab}$${AUTO_VERSION_EXPORT_INLINE} ::AutoVersion::Version version ()" \
    "$${tab}{" \
    "$${tab}$${tab}::AutoVersion::Version result;" \
    "$${tab}$${tab}result.info = ::$${AUTO_VERSION.namespace}::info();" \

# Generation tree of dependencies
for( depend, LOADED_DEPENDS ) {
    AUTO_VERSION_H_TEMP_FILE = "$${AUTO_VERSION.dest_dir}/$${depend}/AutoVersion_p.h"
    AUTO_VERSION_TEMP_NAMESPACE = $${depend}_AutoVersion
    AUTO_VERSION_TEMP_NAMESPACE = $$replace( AUTO_VERSION_TEMP_NAMESPACE, [$$escape_expand(\\W)], _ )
    !isEqual( AUTO_VERSION_TEMP_NAMESPACE, $${AUTO_VERSION.namespace} ) : \
        exists( $${AUTO_VERSION_H_TEMP_FILE} ) : \
            AUTO_VERSION_CPP_CONTENTS += \
                "$${tab}$${tab}{" \
                "$${tab}$${tab}$${tab}::AutoVersion::Dependency dependency;" \
                "$${tab}$${tab}$${tab}dependency.info = ::$${AUTO_VERSION_TEMP_NAMESPACE}::info();" \
                "$${tab}$${tab}$${tab}dependency.version = ::$${AUTO_VERSION_TEMP_NAMESPACE}::version();" \
                "$${tab}$${tab}$${tab}result.dependencies.push_back( dependency );" \
                "$${tab}$${tab}}"
}

AUTO_VERSION_CPP_CONTENTS += \
    "$${tab}$${tab}return result;" \
    "$${tab}}" \
    "}" \

# SOURCE FILE APP ADDITION
equals( AUTO_VERSION.variant, app ) {
    AUTO_VERSION_CPP_CONTENTS += \
        "//" \
        "namespace AutoVersion" \
        "{" \
        "$${tab}::AutoVersion::Version version ()" \
        "$${tab}{" \
        "$${tab}$${tab}return ::$${AUTO_VERSION.namespace}::version();" \
        "$${tab}}" \
        "}"
}

messageLogging( Generate version header file $${AUTO_VERSION.header_file}. )
!isEqual( AUTO_VERSION.variant, header_only ) : \
    messageLogging( Generate version source file $${AUTO_VERSION.source_file}. )

# Механизм QMAKE_SUBSTITUTES с параметром .depends.cache.in не работает для msvc,
# поэтому формирование файла реализовано через echo с перенаправлением в файл.
makeEmptyFile( "$${AUTO_VERSION.header_file}" )
makeEmptyFile( "$${AUTO_VERSION.source_file}" )

appendToFile( "$${AUTO_VERSION.header_file}", $${AUTO_VERSION_H_CONTENTS} )
appendToFile( "$${AUTO_VERSION.source_file}", $${AUTO_VERSION_CPP_CONTENTS} )
appendToFile( "$${AUTO_VERSION.header_file}", $${AUTO_VERSION_H_CONTENTS_END} )

INCLUDEPATH *= \
    $${PWD}/include \

DEPENDPATH *= \
    $${PWD}/include \

DEFINES *= \
    QMAKE_AUTO_VERSION_USED \

unset( tab )
unset( h_line )
unset( cpp_line )
unset( AUTO_VERSION_H_CONTENTS )
unset( AUTO_VERSION_CPP_CONTENTS )
unset( AUTO_VERSION_H_TEMP_FILE )
unset( AUTO_VERSION_TEMP_NAMESPACE )
unset( AUTO_VERSION_EXPORT_DECLARE )
unset( AUTO_VERSION_IMPORT_DECLARE )
unset( AUTO_VERSION_EXPORT_INLINE )
unset( AUTO_VERSION_EXPORT_VALUE )
}
